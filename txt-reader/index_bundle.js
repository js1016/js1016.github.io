!function(e){var n={};function t(r){if(n[r])return n[r].exports;var i=n[r]={i:r,l:!1,exports:{}};return e[r].call(i.exports,i,i.exports,t),i.l=!0,i.exports}t.m=e,t.c=n,t.d=function(e,n,r){t.o(e,n)||Object.defineProperty(e,n,{enumerable:!0,get:r})},t.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},t.t=function(e,n){if(1&n&&(e=t(e)),8&n)return e;if(4&n&&"object"==typeof e&&e&&e.__esModule)return e;var r=Object.create(null);if(t.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:e}),2&n&&"string"!=typeof e)for(var i in e)t.d(r,i,function(n){return e[n]}.bind(null,i));return r},t.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(n,"a",n),n},t.o=function(e,n){return Object.prototype.hasOwnProperty.call(e,n)},t.p="",t(t.s=11)}([function(e,n,t){"use strict";n.__esModule=!0;var r=t(2),i=t(4),s=t(1),o=document.getElementById("status"),a=document.getElementById("file-info"),l=document.getElementById("try-other"),u=document.getElementById("idle"),c=document.getElementById("loading"),d=document.getElementById("progress-bar"),f=document.getElementById("loading-message");function h(){o.classList.add("visible")}function p(){o.classList.remove("visible")}n.init=function(){r.stopDefault(l,"click"),l.addEventListener("click",function(){p(),s.hide(),i.resetFile(),i.show()})},n.setFileInfo=function(e,n){a.innerText=e+" ("+n+" lines)"},n.showIdle=function(){h(),c.classList.add("hide"),u.classList.remove("hide")},n.hideStatusBar=p,n.showLoading=function(){h(),u.classList.add("hide"),c.classList.remove("hide")},n.setLoadingPercentage=function(e){d.style.width=e+"%"},n.setLoadingMessage=function(e){f.innerText=e}},function(e,n,t){"use strict";n.__esModule=!0;var r=t(3),i=t(2),s=t(0),o=document.getElementById("main"),a=document.getElementById("view-first"),l=document.getElementById("view-next"),u=document.getElementById("view-last"),c=document.getElementById("run-button"),d=document.getElementById("console"),f=document.getElementById("clear-console"),h=document.getElementById("results"),p=document.getElementById("start-row"),m=document.getElementById("row-size"),g=1;function _(e){w(e,!1)}function b(e){w(e,!0)}function w(e,n){var t=document.createElement("div");t.innerText=e,t.className=n?"err":"log",d.appendChild(t),d.scrollTop=d.scrollHeight}function v(e,n){_("Call method: reader.getLine("+e+", "+n+")"),r.reader.getLines(e,n).progress(function(e){i.displayLoading("Getting lines...",e)}).then(function(t){(g=e+n)>r.reader.lineCount&&(g=1),s.showIdle(),_("getLine completed. Time taken: "+t.timeTaken+"ms. Returned "+t.result.length+" lines."),function(e,n){for(var t="",r=0;r<e.length;r++)t+='<div class="line"><div class="line-indicator">'+(n+r)+'</div><div class="content">'+i.encodeHTML(e[r])+"</div></div>";h.innerHTML=t}(t.result,e)}).catch(function(e){b("getLine failed with error: "+e)})}n.init=function(){a.addEventListener("click",function(){v(1,50)}),u.addEventListener("click",function(){v(r.reader.lineCount>50?r.reader.lineCount-49:1,50)}),l.addEventListener("click",function(){v(g,50)}),c.addEventListener("click",function(){var e=Number(p.value);e<=0?b("Start line number is invalid."):v(e,Number(m.value))}),f.addEventListener("click",function(){d.innerHTML=""}),i.stopDefault(f,"click")},n.show=function(){o.classList.remove("hide")},n.hide=function(){o.classList.add("hide")},n.log=_,n.error=b,n.clearResults=function(){h.innerHTML=""}},function(e,n,t){"use strict";n.__esModule=!0,t(6);var r=t(0);n.stopDefault=function(e,n){for(var t=n.split(" "),r=0;r<t.length;r++)e.addEventListener(t[r],function(e){e.preventDefault(),e.stopPropagation()})},n.displayLoading=function(e,n){r.showLoading(),r.setLoadingMessage(e+" "+n+"%"),r.setLoadingPercentage(n)},n.encodeHTML=function(e){return document.createElement("div").appendChild(document.createTextNode(e)).parentNode.innerHTML}},function(e,n,t){"use strict";n.__esModule=!0;var r=t(5);n.reader=new r.TxtReader},function(e,n,t){"use strict";n.__esModule=!0;var r=t(2),i=t(0),s=t(1),o=t(3),a=document.getElementById("box"),l=document.getElementById("file-input");function u(){a.style.marginTop="-"+(a.offsetHeight+a.offsetTop)+"px"}function c(){a.classList.remove("hide"),setTimeout(function(){a.style.marginTop="100px"},0)}function d(e){var n;u(),n=e[0],r.displayLoading("Loading file: "+n.name+"...",0),s.log("Call method: reader.loadFile(file)"),o.reader.loadFile(n).progress(function(e){r.displayLoading("Loading file: "+n.name+"...",e)}).then(function(e){s.clearResults(),i.setFileInfo(n.name,e.result.lineCount),s.log("loadFile completed. Time taken: "+e.timeTaken+"ms. Line count: "+e.result.lineCount+"."),i.showIdle(),s.show()}).catch(function(e){i.hideStatusBar(),alert("wrong"),c()})}n.init=function(){r.stopDefault(a,"drag dragstart dragend dragover dragenter dragleave drop"),a.addEventListener("drop",function(e){e.dataTransfer.files.length>0&&d(e.dataTransfer.files)}),l.addEventListener("change",function(e){this.files.length>0&&d(this.files)}),a.addEventListener("transitionend",function(){this.style.marginTop.startsWith("-")&&this.classList.add("hide")})},n.resetFile=function(){l.value=""},n.hide=u,n.show=c},function(module,exports){!function(e){var n={};function t(r){if(n[r])return n[r].exports;var i=n[r]={i:r,l:!1,exports:{}};return e[r].call(i.exports,i,i.exports,t),i.l=!0,i.exports}t.m=e,t.c=n,t.d=function(e,n,r){t.o(e,n)||Object.defineProperty(e,n,{configurable:!1,enumerable:!0,get:r})},t.r=function(e){Object.defineProperty(e,"__esModule",{value:!0})},t.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(n,"a",n),n},t.o=function(e,n){return Object.prototype.hasOwnProperty.call(e,n)},t.p="",t(t.s="./factory/txt-reader-for-node.js")}({"./factory/txt-reader-for-node.js":
/*!****************************************!*\
  !*** ./factory/txt-reader-for-node.js ***!
  \****************************************/
/*! no exports provided */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _txt_reader_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../txt-reader.ts */ "./txt-reader.ts");\n/* harmony import */ var _txt_reader_ts__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_txt_reader_ts__WEBPACK_IMPORTED_MODULE_0__);\n\r\nexports.TxtReader = _txt_reader_ts__WEBPACK_IMPORTED_MODULE_0__["TxtReader"]; \n\n//# sourceURL=webpack:///./factory/txt-reader-for-node.js?')},"./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */function(module,exports){eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n//# sourceURL=webpack:///./node_modules/process/browser.js?")},"./node_modules/promise-polyfill/src/index.js":
/*!****************************************************!*\
  !*** ./node_modules/promise-polyfill/src/index.js ***!
  \****************************************************/
/*! exports provided: default */function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(setImmediate) {// Store setTimeout reference so promise-polyfill will be unaffected by\n// other code modifying setTimeout (like sinon.useFakeTimers())\nvar setTimeoutFunc = setTimeout;\n\nfunction noop() {}\n\n// Polyfill for Function.prototype.bind\nfunction bind(fn, thisArg) {\n  return function() {\n    fn.apply(thisArg, arguments);\n  };\n}\n\nfunction Promise(fn) {\n  if (!(this instanceof Promise))\n    throw new TypeError('Promises must be constructed via new');\n  if (typeof fn !== 'function') throw new TypeError('not a function');\n  this._state = 0;\n  this._handled = false;\n  this._value = undefined;\n  this._deferreds = [];\n\n  doResolve(fn, this);\n}\n\nfunction handle(self, deferred) {\n  while (self._state === 3) {\n    self = self._value;\n  }\n  if (self._state === 0) {\n    self._deferreds.push(deferred);\n    return;\n  }\n  self._handled = true;\n  Promise._immediateFn(function() {\n    var cb = self._state === 1 ? deferred.onFulfilled : deferred.onRejected;\n    if (cb === null) {\n      (self._state === 1 ? resolve : reject)(deferred.promise, self._value);\n      return;\n    }\n    var ret;\n    try {\n      ret = cb(self._value);\n    } catch (e) {\n      reject(deferred.promise, e);\n      return;\n    }\n    resolve(deferred.promise, ret);\n  });\n}\n\nfunction resolve(self, newValue) {\n  try {\n    // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure\n    if (newValue === self)\n      throw new TypeError('A promise cannot be resolved with itself.');\n    if (\n      newValue &&\n      (typeof newValue === 'object' || typeof newValue === 'function')\n    ) {\n      var then = newValue.then;\n      if (newValue instanceof Promise) {\n        self._state = 3;\n        self._value = newValue;\n        finale(self);\n        return;\n      } else if (typeof then === 'function') {\n        doResolve(bind(then, newValue), self);\n        return;\n      }\n    }\n    self._state = 1;\n    self._value = newValue;\n    finale(self);\n  } catch (e) {\n    reject(self, e);\n  }\n}\n\nfunction reject(self, newValue) {\n  self._state = 2;\n  self._value = newValue;\n  finale(self);\n}\n\nfunction finale(self) {\n  if (self._state === 2 && self._deferreds.length === 0) {\n    Promise._immediateFn(function() {\n      if (!self._handled) {\n        Promise._unhandledRejectionFn(self._value);\n      }\n    });\n  }\n\n  for (var i = 0, len = self._deferreds.length; i < len; i++) {\n    handle(self, self._deferreds[i]);\n  }\n  self._deferreds = null;\n}\n\nfunction Handler(onFulfilled, onRejected, promise) {\n  this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;\n  this.onRejected = typeof onRejected === 'function' ? onRejected : null;\n  this.promise = promise;\n}\n\n/**\n * Take a potentially misbehaving resolver function and make sure\n * onFulfilled and onRejected are only called once.\n *\n * Makes no guarantees about asynchrony.\n */\nfunction doResolve(fn, self) {\n  var done = false;\n  try {\n    fn(\n      function(value) {\n        if (done) return;\n        done = true;\n        resolve(self, value);\n      },\n      function(reason) {\n        if (done) return;\n        done = true;\n        reject(self, reason);\n      }\n    );\n  } catch (ex) {\n    if (done) return;\n    done = true;\n    reject(self, ex);\n  }\n}\n\nPromise.prototype['catch'] = function(onRejected) {\n  return this.then(null, onRejected);\n};\n\nPromise.prototype.then = function(onFulfilled, onRejected) {\n  var prom = new this.constructor(noop);\n\n  handle(this, new Handler(onFulfilled, onRejected, prom));\n  return prom;\n};\n\nPromise.prototype['finally'] = function(callback) {\n  var constructor = this.constructor;\n  return this.then(\n    function(value) {\n      return constructor.resolve(callback()).then(function() {\n        return value;\n      });\n    },\n    function(reason) {\n      return constructor.resolve(callback()).then(function() {\n        return constructor.reject(reason);\n      });\n    }\n  );\n};\n\nPromise.all = function(arr) {\n  return new Promise(function(resolve, reject) {\n    if (!arr || typeof arr.length === 'undefined')\n      throw new TypeError('Promise.all accepts an array');\n    var args = Array.prototype.slice.call(arr);\n    if (args.length === 0) return resolve([]);\n    var remaining = args.length;\n\n    function res(i, val) {\n      try {\n        if (val && (typeof val === 'object' || typeof val === 'function')) {\n          var then = val.then;\n          if (typeof then === 'function') {\n            then.call(\n              val,\n              function(val) {\n                res(i, val);\n              },\n              reject\n            );\n            return;\n          }\n        }\n        args[i] = val;\n        if (--remaining === 0) {\n          resolve(args);\n        }\n      } catch (ex) {\n        reject(ex);\n      }\n    }\n\n    for (var i = 0; i < args.length; i++) {\n      res(i, args[i]);\n    }\n  });\n};\n\nPromise.resolve = function(value) {\n  if (value && typeof value === 'object' && value.constructor === Promise) {\n    return value;\n  }\n\n  return new Promise(function(resolve) {\n    resolve(value);\n  });\n};\n\nPromise.reject = function(value) {\n  return new Promise(function(resolve, reject) {\n    reject(value);\n  });\n};\n\nPromise.race = function(values) {\n  return new Promise(function(resolve, reject) {\n    for (var i = 0, len = values.length; i < len; i++) {\n      values[i].then(resolve, reject);\n    }\n  });\n};\n\n// Use polyfill for setImmediate for performance gains\nPromise._immediateFn =\n  (typeof setImmediate === 'function' &&\n    function(fn) {\n      setImmediate(fn);\n    }) ||\n  function(fn) {\n    setTimeoutFunc(fn, 0);\n  };\n\nPromise._unhandledRejectionFn = function _unhandledRejectionFn(err) {\n  if (typeof console !== 'undefined' && console) {\n    console.warn('Possible Unhandled Promise Rejection:', err); // eslint-disable-line no-console\n  }\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Promise);\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../timers-browserify/main.js */ \"./node_modules/timers-browserify/main.js\").setImmediate))\n\n//# sourceURL=webpack:///./node_modules/promise-polyfill/src/index.js?")},"./node_modules/promise-polyfill/src/polyfill.js":
/*!*******************************************************!*\
  !*** ./node_modules/promise-polyfill/src/polyfill.js ***!
  \*******************************************************/
/*! no exports provided */function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(global) {/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index */ \"./node_modules/promise-polyfill/src/index.js\");\n\n\nvar globalNS = (function() {\n  // the only reliable means to get the global object is\n  // `Function('return this')()`\n  // However, this causes CSP violations in Chrome apps.\n  if (typeof self !== 'undefined') {\n    return self;\n  }\n  if (typeof window !== 'undefined') {\n    return window;\n  }\n  if (typeof global !== 'undefined') {\n    return global;\n  }\n  throw new Error('unable to locate global object');\n})();\n\nif (!globalNS.Promise) {\n  globalNS.Promise = _index__WEBPACK_IMPORTED_MODULE_0__[\"default\"];\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///./node_modules/promise-polyfill/src/polyfill.js?")},"./node_modules/setimmediate/setImmediate.js":
/*!***************************************************!*\
  !*** ./node_modules/setimmediate/setImmediate.js ***!
  \***************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {\n    "use strict";\n\n    if (global.setImmediate) {\n        return;\n    }\n\n    var nextHandle = 1; // Spec says greater than zero\n    var tasksByHandle = {};\n    var currentlyRunningATask = false;\n    var doc = global.document;\n    var registerImmediate;\n\n    function setImmediate(callback) {\n      // Callback can either be a function or a string\n      if (typeof callback !== "function") {\n        callback = new Function("" + callback);\n      }\n      // Copy function arguments\n      var args = new Array(arguments.length - 1);\n      for (var i = 0; i < args.length; i++) {\n          args[i] = arguments[i + 1];\n      }\n      // Store and register the task\n      var task = { callback: callback, args: args };\n      tasksByHandle[nextHandle] = task;\n      registerImmediate(nextHandle);\n      return nextHandle++;\n    }\n\n    function clearImmediate(handle) {\n        delete tasksByHandle[handle];\n    }\n\n    function run(task) {\n        var callback = task.callback;\n        var args = task.args;\n        switch (args.length) {\n        case 0:\n            callback();\n            break;\n        case 1:\n            callback(args[0]);\n            break;\n        case 2:\n            callback(args[0], args[1]);\n            break;\n        case 3:\n            callback(args[0], args[1], args[2]);\n            break;\n        default:\n            callback.apply(undefined, args);\n            break;\n        }\n    }\n\n    function runIfPresent(handle) {\n        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."\n        // So if we\'re currently running a task, we\'ll need to delay this invocation.\n        if (currentlyRunningATask) {\n            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n            // "too much recursion" error.\n            setTimeout(runIfPresent, 0, handle);\n        } else {\n            var task = tasksByHandle[handle];\n            if (task) {\n                currentlyRunningATask = true;\n                try {\n                    run(task);\n                } finally {\n                    clearImmediate(handle);\n                    currentlyRunningATask = false;\n                }\n            }\n        }\n    }\n\n    function installNextTickImplementation() {\n        registerImmediate = function(handle) {\n            process.nextTick(function () { runIfPresent(handle); });\n        };\n    }\n\n    function canUsePostMessage() {\n        // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n        // where `global.postMessage` means something completely different and can\'t be used for this purpose.\n        if (global.postMessage && !global.importScripts) {\n            var postMessageIsAsynchronous = true;\n            var oldOnMessage = global.onmessage;\n            global.onmessage = function() {\n                postMessageIsAsynchronous = false;\n            };\n            global.postMessage("", "*");\n            global.onmessage = oldOnMessage;\n            return postMessageIsAsynchronous;\n        }\n    }\n\n    function installPostMessageImplementation() {\n        // Installs an event handler on `global` for the `message` event: see\n        // * https://developer.mozilla.org/en/DOM/window.postMessage\n        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n\n        var messagePrefix = "setImmediate$" + Math.random() + "$";\n        var onGlobalMessage = function(event) {\n            if (event.source === global &&\n                typeof event.data === "string" &&\n                event.data.indexOf(messagePrefix) === 0) {\n                runIfPresent(+event.data.slice(messagePrefix.length));\n            }\n        };\n\n        if (global.addEventListener) {\n            global.addEventListener("message", onGlobalMessage, false);\n        } else {\n            global.attachEvent("onmessage", onGlobalMessage);\n        }\n\n        registerImmediate = function(handle) {\n            global.postMessage(messagePrefix + handle, "*");\n        };\n    }\n\n    function installMessageChannelImplementation() {\n        var channel = new MessageChannel();\n        channel.port1.onmessage = function(event) {\n            var handle = event.data;\n            runIfPresent(handle);\n        };\n\n        registerImmediate = function(handle) {\n            channel.port2.postMessage(handle);\n        };\n    }\n\n    function installReadyStateChangeImplementation() {\n        var html = doc.documentElement;\n        registerImmediate = function(handle) {\n            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n            // into the document. Do so, thus queuing up the task. Remember to clean up once it\'s been called.\n            var script = doc.createElement("script");\n            script.onreadystatechange = function () {\n                runIfPresent(handle);\n                script.onreadystatechange = null;\n                html.removeChild(script);\n                script = null;\n            };\n            html.appendChild(script);\n        };\n    }\n\n    function installSetTimeoutImplementation() {\n        registerImmediate = function(handle) {\n            setTimeout(runIfPresent, 0, handle);\n        };\n    }\n\n    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\n    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);\n    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;\n\n    // Don\'t get fooled by e.g. browserify environments.\n    if ({}.toString.call(global.process) === "[object process]") {\n        // For Node.js before 0.9\n        installNextTickImplementation();\n\n    } else if (canUsePostMessage()) {\n        // For non-IE10 modern browsers\n        installPostMessageImplementation();\n\n    } else if (global.MessageChannel) {\n        // For web workers, where supported\n        installMessageChannelImplementation();\n\n    } else if (doc && "onreadystatechange" in doc.createElement("script")) {\n        // For IE 6–8\n        installReadyStateChangeImplementation();\n\n    } else {\n        // For older browsers\n        installSetTimeoutImplementation();\n    }\n\n    attachTo.setImmediate = setImmediate;\n    attachTo.clearImmediate = clearImmediate;\n}(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self));\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../process/browser.js */ "./node_modules/process/browser.js")))\n\n//# sourceURL=webpack:///./node_modules/setimmediate/setImmediate.js?')},"./node_modules/text-encoding-shim/index.js":
/*!**************************************************!*\
  !*** ./node_modules/text-encoding-shim/index.js ***!
  \**************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (root, factory) {\r\n    if (true) {\r\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\r\n    } else { var textEncoding; }\r\n}(this, function () {\r\n\t\"use strict\";\r\n\t// return native implementation if available\r\n\tvar g = typeof GLOBAL !== 'undefined' ? GLOBAL : window;\r\n\tif (typeof g.TextEncoder !== 'undefined' && typeof g.TextDecoder !== 'undefined') {\r\n\t\treturn {'TextEncoder': g.TextEncoder, 'TextDecoder': g.TextDecoder};\r\n\t}\r\n\r\n\t// allowed encoding strings for utf-8\r\n\tvar utf8Encodings = [\r\n\t\t'utf8',\r\n\t\t'utf-8',\r\n\t\t'unicode-1-1-utf-8'\r\n\t];\r\n\r\n\tvar TextEncoder = function(encoding) {\r\n\t\tif (utf8Encodings.indexOf(encoding) < 0 && typeof encoding !== 'undefined' && encoding != null) {\r\n\t\t\tthrow new RangeError('Invalid encoding type. Only utf-8 is supported');\r\n\t\t} else {\r\n\t\t\tthis.encoding = 'utf-8';\r\n\t\t\tthis.encode = function(str) {\r\n\t\t\t\tif (typeof str !== 'string') {\r\n\t\t\t\t\tthrow new TypeError('passed argument must be of tye string');\r\n\t\t\t\t}\r\n\t\t\t\tvar binstr = unescape(encodeURIComponent(str)),\r\n\t\t\t\t\tarr = new Uint8Array(binstr.length);\r\n\t\t\t\tbinstr.split('').forEach(function(char, i) {\r\n\t\t\t\t\tarr[i] = char.charCodeAt(0);\r\n\t\t\t\t});\r\n\t\t\t\treturn arr;\r\n\t\t\t};\r\n\t\t}\r\n\t}\r\n\r\n\tvar TextDecoder = function(encoding, options) {\r\n\t\tif (utf8Encodings.indexOf(encoding) < 0 && typeof encoding !== 'undefined' && encoding != null) {\r\n\t\t\tthrow new RangeError('Invalid encoding type. Only utf-8 is supported');\r\n\t\t}\r\n\t\telse {\r\n\t\t\tthis.encoding = 'utf-8';\r\n\t\t\tthis.ignoreBOM = false;\r\n\t\t\tthis.fatal = (typeof options !== 'undefined' && fatal in options) ? options.fatal : false;\r\n\t\t\tif (typeof this.fatal !== 'boolean') {\r\n\t\t\t\tthrow new TypeError('fatal flag must be boolean');\r\n\t\t\t}\r\n\t\t\tthis.decode = function (view, options) {\r\n\t\t\t\tif (typeof view === 'undefined') {\r\n\t\t\t\t\treturn '';\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar stream = (typeof options !== 'undefined' && stream in options) ? options.stream : false;\r\n\t\t\t\tif (typeof stream !== 'boolean') {\r\n\t\t\t\t\tthrow new TypeError('stream option must be boolean');\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (!ArrayBuffer.isView(view)) {\r\n\t\t\t\t\tthrow new TypeError('passed argument must be an array buffer view');\r\n\t\t\t\t} else {\r\n\t\t\t\t\tvar arr = new Uint8Array(view.buffer),\r\n\t\t\t\t\t\tcharArr = new Array(arr.length);\r\n\t\t\t\t\tarr.forEach(function(charcode, i) {\r\n\t\t\t\t\t\tcharArr[i] = String.fromCharCode(charcode);\r\n\t\t\t\t\t});\r\n\t\t\t\t\treturn decodeURIComponent(escape(charArr.join('')));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn {'TextEncoder': TextEncoder, 'TextDecoder': TextDecoder};\r\n}));\n\n//# sourceURL=webpack:///./node_modules/text-encoding-shim/index.js?")},"./node_modules/timers-browserify/main.js":
/*!************************************************!*\
  !*** ./node_modules/timers-browserify/main.js ***!
  \************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('/* WEBPACK VAR INJECTION */(function(global) {var scope = (typeof global !== "undefined" && global) ||\n            (typeof self !== "undefined" && self) ||\n            window;\nvar apply = Function.prototype.apply;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function() {\n  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);\n};\nexports.setInterval = function() {\n  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);\n};\nexports.clearTimeout =\nexports.clearInterval = function(timeout) {\n  if (timeout) {\n    timeout.close();\n  }\n};\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\nTimeout.prototype.close = function() {\n  this._clearFn.call(scope, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function(item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function(item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function(item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout)\n        item._onTimeout();\n    }, msecs);\n  }\n};\n\n// setimmediate attaches itself to the global object\n__webpack_require__(/*! setimmediate */ "./node_modules/setimmediate/setImmediate.js");\n// On some exotic environments, it\'s not clear which object `setimmediate` was\n// able to install onto.  Search each possibility in the same order as the\n// `setimmediate` library.\nexports.setImmediate = (typeof self !== "undefined" && self.setImmediate) ||\n                       (typeof global !== "undefined" && global.setImmediate) ||\n                       (this && this.setImmediate);\nexports.clearImmediate = (typeof self !== "undefined" && self.clearImmediate) ||\n                         (typeof global !== "undefined" && global.clearImmediate) ||\n                         (this && this.clearImmediate);\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))\n\n//# sourceURL=webpack:///./node_modules/timers-browserify/main.js?')},"./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */function(module,exports){eval('var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || Function("return this")() || (1, eval)("this");\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === "object") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it\'s\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n\n//# sourceURL=webpack:///(webpack)/buildin/global.js?')},"./polyfill.ts":
/*!*********************!*\
  !*** ./polyfill.ts ***!
  \*********************/
/*! no static exports found */function(module,exports){eval("if (Uint8Array.prototype.indexOf === undefined) {\r\n    Uint8Array.prototype.indexOf = function (value) {\r\n        return Array.prototype.indexOf.call(this, value);\r\n    };\r\n}\r\nif (Uint8Array.prototype.slice === undefined) {\r\n    Uint8Array.prototype.slice = function (begin, end) {\r\n        return new Uint8Array(Array.prototype.slice.call(this, begin, end));\r\n    };\r\n}\r\nif (!Uint8Array.prototype.forEach) {\r\n    Uint8Array.prototype.forEach = function (callback /*, thisArg*/) {\r\n        var T, k;\r\n        if (this == null) {\r\n            throw new TypeError('this is null or not defined');\r\n        }\r\n        // 1. Let O be the result of calling toObject() passing the\r\n        // |this| value as the argument.\r\n        var O = Object(this);\r\n        // 2. Let lenValue be the result of calling the Get() internal\r\n        // method of O with the argument \"length\".\r\n        // 3. Let len be toUint32(lenValue).\r\n        var len = O.length >>> 0;\r\n        // 4. If isCallable(callback) is false, throw a TypeError exception. \r\n        // See: http://es5.github.com/#x9.11\r\n        if (typeof callback !== 'function') {\r\n            throw new TypeError(callback + ' is not a function');\r\n        }\r\n        // 5. If thisArg was supplied, let T be thisArg; else let\r\n        // T be undefined.\r\n        if (arguments.length > 1) {\r\n            T = arguments[1];\r\n        }\r\n        // 6. Let k be 0.\r\n        k = 0;\r\n        // 7. Repeat while k < len.\r\n        while (k < len) {\r\n            var kValue;\r\n            // a. Let Pk be ToString(k).\r\n            //    This is implicit for LHS operands of the in operator.\r\n            // b. Let kPresent be the result of calling the HasProperty\r\n            //    internal method of O with argument Pk.\r\n            //    This step can be combined with c.\r\n            // c. If kPresent is true, then\r\n            if (k in O) {\r\n                // i. Let kValue be the result of calling the Get internal\r\n                // method of O with argument Pk.\r\n                kValue = O[k];\r\n                // ii. Call the Call internal method of callback with T as\r\n                // the this value and argument list containing kValue, k, and O.\r\n                callback.call(T, kValue, k, O);\r\n            }\r\n            // d. Increase k by 1.\r\n            k++;\r\n        }\r\n        // 8. return undefined.\r\n    };\r\n}\r\n\n\n//# sourceURL=webpack:///./polyfill.ts?")},"./text-encoding.ts":
/*!**************************!*\
  !*** ./text-encoding.ts ***!
  \**************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("\r\n// This file is used to fix an issue in text-encoding-shim\r\n// See https://gitlab.com/PseudoPsycho/text-encoding-shim/issues/1 for details\r\nexports.__esModule = true;\r\nif (typeof window === 'undefined' && typeof self !== 'undefined') {\r\n    self['window'] = self;\r\n}\r\nvar text_encoding_shim_1 = __webpack_require__(/*! text-encoding-shim */ \"./node_modules/text-encoding-shim/index.js\");\r\nexports.TextDecoder = text_encoding_shim_1.TextDecoder;\r\n\n\n//# sourceURL=webpack:///./text-encoding.ts?")},"./txt-reader.ts":
/*!***********************!*\
  !*** ./txt-reader.ts ***!
  \***********************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("\r\nexports.__esModule = true;\r\nvar text_encoding_1 = __webpack_require__(/*! ./text-encoding */ \"./text-encoding.ts\");\r\n__webpack_require__(/*! promise-polyfill/src/polyfill */ \"./node_modules/promise-polyfill/src/polyfill.js\");\r\n__webpack_require__(/*! ./polyfill */ \"./polyfill.ts\");\r\nvar RequestMessage = /** @class */ (function () {\r\n    function RequestMessage(action, data) {\r\n        this.action = action;\r\n        this.data = data !== undefined ? data : null;\r\n    }\r\n    return RequestMessage;\r\n}());\r\nvar TxtReaderTaskState;\r\n(function (TxtReaderTaskState) {\r\n    TxtReaderTaskState[TxtReaderTaskState[\"Initialized\"] = 0] = \"Initialized\";\r\n    TxtReaderTaskState[TxtReaderTaskState[\"Queued\"] = 1] = \"Queued\";\r\n    TxtReaderTaskState[TxtReaderTaskState[\"Running\"] = 2] = \"Running\";\r\n    TxtReaderTaskState[TxtReaderTaskState[\"Completed\"] = 3] = \"Completed\";\r\n})(TxtReaderTaskState || (TxtReaderTaskState = {}));\r\nvar TxtReaderTask = /** @class */ (function () {\r\n    function TxtReaderTask(id, reqMsg, parser) {\r\n        var _this = this;\r\n        this.id = id;\r\n        this.requestMessage = reqMsg;\r\n        this.parser = parser;\r\n        this.requestMessage.taskId = id;\r\n        this.state = TxtReaderTaskState.Initialized;\r\n        this.onProgress = null;\r\n        this.startTime = 0;\r\n        // initialize the task promise object, assign the resolve, reject methods.\r\n        this.promise = new Promise(function (resolve, reject) {\r\n            _this.resolve = resolve;\r\n            _this.reject = reject;\r\n        });\r\n    }\r\n    TxtReaderTask.prototype.dispose = function () {\r\n        // release the memory inside promise obejct\r\n        this.resolve = null;\r\n        this.reject = null;\r\n        this.promise = null;\r\n    };\r\n    // run the task, postMessage would be triggered in TxtReader\r\n    // just change the state and record the task start time here\r\n    TxtReaderTask.prototype.run = function () {\r\n        this.state = TxtReaderTaskState.Running;\r\n        this.startTime = new Date().getTime();\r\n    };\r\n    // be called when a task completes no matter it succeeds or fails\r\n    TxtReaderTask.prototype.complete = function (response) {\r\n        this.state = TxtReaderTaskState.Completed;\r\n        var timeTaken = new Date().getTime() - this.startTime;\r\n        if (response.success) {\r\n            var taskResponse = {\r\n                timeTaken: timeTaken,\r\n                message: response.message,\r\n                result: response.result\r\n            };\r\n            this.resolve(taskResponse);\r\n        }\r\n        else {\r\n            this.reject(response.message);\r\n        }\r\n        this.dispose();\r\n    };\r\n    TxtReaderTask.prototype.updateProgress = function (progress) {\r\n        if (this.onProgress !== null) {\r\n            this.onProgress.call(this.parser, progress);\r\n        }\r\n    };\r\n    TxtReaderTask.prototype.then = function (onFulFilled) {\r\n        var _this = this;\r\n        this.promise.then(function (data) {\r\n            onFulFilled.call(_this.parser, data);\r\n        })[\"catch\"](function (reason) { });\r\n        return this;\r\n    };\r\n    TxtReaderTask.prototype[\"catch\"] = function (onFailed) {\r\n        var _this = this;\r\n        this.promise[\"catch\"](function (reason) {\r\n            onFailed.call(_this.parser, reason);\r\n        });\r\n        return this;\r\n    };\r\n    TxtReaderTask.prototype.progress = function (onProgress) {\r\n        this.onProgress = onProgress;\r\n        return this;\r\n    };\r\n    return TxtReaderTask;\r\n}());\r\nvar TxtReader = /** @class */ (function () {\r\n    function TxtReader() {\r\n        var _this = this;\r\n        this.taskList = [];\r\n        this.runningTask = null;\r\n        this.queuedTaskList = [];\r\n        this.verboseLogging = false;\r\n        this.utf8decoder = new text_encoding_1.TextDecoder('utf-8');\r\n        this.lineCount = 0;\r\n        Object.defineProperty(this, 'lineCount', {\r\n            value: 0,\r\n            writable: false\r\n        });\r\n        this.file = null;\r\n        this.worker = new Worker(window.URL.createObjectURL(new Blob([\"/******/ (function(modules) { // webpackBootstrap\\n/******/ \\t// The module cache\\n/******/ \\tvar installedModules = {};\\n/******/\\n/******/ \\t// The require function\\n/******/ \\tfunction __webpack_require__(moduleId) {\\n/******/\\n/******/ \\t\\t// Check if module is in cache\\n/******/ \\t\\tif(installedModules[moduleId]) {\\n/******/ \\t\\t\\treturn installedModules[moduleId].exports;\\n/******/ \\t\\t}\\n/******/ \\t\\t// Create a new module (and put it into the cache)\\n/******/ \\t\\tvar module = installedModules[moduleId] = {\\n/******/ \\t\\t\\ti: moduleId,\\n/******/ \\t\\t\\tl: false,\\n/******/ \\t\\t\\texports: {}\\n/******/ \\t\\t};\\n/******/\\n/******/ \\t\\t// Execute the module function\\n/******/ \\t\\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\\n/******/\\n/******/ \\t\\t// Flag the module as loaded\\n/******/ \\t\\tmodule.l = true;\\n/******/\\n/******/ \\t\\t// Return the exports of the module\\n/******/ \\t\\treturn module.exports;\\n/******/ \\t}\\n/******/\\n/******/\\n/******/ \\t// expose the modules object (__webpack_modules__)\\n/******/ \\t__webpack_require__.m = modules;\\n/******/\\n/******/ \\t// expose the module cache\\n/******/ \\t__webpack_require__.c = installedModules;\\n/******/\\n/******/ \\t// define getter function for harmony exports\\n/******/ \\t__webpack_require__.d = function(exports, name, getter) {\\n/******/ \\t\\tif(!__webpack_require__.o(exports, name)) {\\n/******/ \\t\\t\\tObject.defineProperty(exports, name, {\\n/******/ \\t\\t\\t\\tconfigurable: false,\\n/******/ \\t\\t\\t\\tenumerable: true,\\n/******/ \\t\\t\\t\\tget: getter\\n/******/ \\t\\t\\t});\\n/******/ \\t\\t}\\n/******/ \\t};\\n/******/\\n/******/ \\t// define __esModule on exports\\n/******/ \\t__webpack_require__.r = function(exports) {\\n/******/ \\t\\tObject.defineProperty(exports, \\'__esModule\\', { value: true });\\n/******/ \\t};\\n/******/\\n/******/ \\t// getDefaultExport function for compatibility with non-harmony modules\\n/******/ \\t__webpack_require__.n = function(module) {\\n/******/ \\t\\tvar getter = module && module.__esModule ?\\n/******/ \\t\\t\\tfunction getDefault() { return module[\\'default\\']; } :\\n/******/ \\t\\t\\tfunction getModuleExports() { return module; };\\n/******/ \\t\\t__webpack_require__.d(getter, \\'a\\', getter);\\n/******/ \\t\\treturn getter;\\n/******/ \\t};\\n/******/\\n/******/ \\t// Object.prototype.hasOwnProperty.call\\n/******/ \\t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\\n/******/\\n/******/ \\t// __webpack_public_path__\\n/******/ \\t__webpack_require__.p = \\\"\\\";\\n/******/\\n/******/\\n/******/ \\t// Load entry module and return exports\\n/******/ \\treturn __webpack_require__(__webpack_require__.s = \\\"./txt-reader-worker.ts\\\");\\n/******/ })\\n/************************************************************************/\\n/******/ ({\\n\\n/***/ \\\"./node_modules/text-encoding-shim/index.js\\\":\\n/*!**************************************************!*\\\\\\n  !*** ./node_modules/text-encoding-shim/index.js ***!\\n  \\\\**************************************************/\\n/*! no static exports found */\\n/***/ (function(module, exports, __webpack_require__) {\\n\\neval(\\\"var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (root, factory) {\\\\r\\\\n    if (true) {\\\\r\\\\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\\\\n\\\\t\\\\t\\\\t\\\\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === \\'function\\' ?\\\\n\\\\t\\\\t\\\\t\\\\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\\\\n\\\\t\\\\t\\\\t\\\\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\\\\r\\\\n    } else { var textEncoding; }\\\\r\\\\n}(this, function () {\\\\r\\\\n\\\\t\\\\\\\"use strict\\\\\\\";\\\\r\\\\n\\\\t// return native implementation if available\\\\r\\\\n\\\\tvar g = typeof GLOBAL !== \\'undefined\\' ? GLOBAL : window;\\\\r\\\\n\\\\tif (typeof g.TextEncoder !== \\'undefined\\' && typeof g.TextDecoder !== \\'undefined\\') {\\\\r\\\\n\\\\t\\\\treturn {\\'TextEncoder\\': g.TextEncoder, \\'TextDecoder\\': g.TextDecoder};\\\\r\\\\n\\\\t}\\\\r\\\\n\\\\r\\\\n\\\\t// allowed encoding strings for utf-8\\\\r\\\\n\\\\tvar utf8Encodings = [\\\\r\\\\n\\\\t\\\\t\\'utf8\\',\\\\r\\\\n\\\\t\\\\t\\'utf-8\\',\\\\r\\\\n\\\\t\\\\t\\'unicode-1-1-utf-8\\'\\\\r\\\\n\\\\t];\\\\r\\\\n\\\\r\\\\n\\\\tvar TextEncoder = function(encoding) {\\\\r\\\\n\\\\t\\\\tif (utf8Encodings.indexOf(encoding) < 0 && typeof encoding !== \\'undefined\\' && encoding != null) {\\\\r\\\\n\\\\t\\\\t\\\\tthrow new RangeError(\\'Invalid encoding type. Only utf-8 is supported\\');\\\\r\\\\n\\\\t\\\\t} else {\\\\r\\\\n\\\\t\\\\t\\\\tthis.encoding = \\'utf-8\\';\\\\r\\\\n\\\\t\\\\t\\\\tthis.encode = function(str) {\\\\r\\\\n\\\\t\\\\t\\\\t\\\\tif (typeof str !== \\'string\\') {\\\\r\\\\n\\\\t\\\\t\\\\t\\\\t\\\\tthrow new TypeError(\\'passed argument must be of tye string\\');\\\\r\\\\n\\\\t\\\\t\\\\t\\\\t}\\\\r\\\\n\\\\t\\\\t\\\\t\\\\tvar binstr = unescape(encodeURIComponent(str)),\\\\r\\\\n\\\\t\\\\t\\\\t\\\\t\\\\tarr = new Uint8Array(binstr.length);\\\\r\\\\n\\\\t\\\\t\\\\t\\\\tbinstr.split(\\'\\').forEach(function(char, i) {\\\\r\\\\n\\\\t\\\\t\\\\t\\\\t\\\\tarr[i] = char.charCodeAt(0);\\\\r\\\\n\\\\t\\\\t\\\\t\\\\t});\\\\r\\\\n\\\\t\\\\t\\\\t\\\\treturn arr;\\\\r\\\\n\\\\t\\\\t\\\\t};\\\\r\\\\n\\\\t\\\\t}\\\\r\\\\n\\\\t}\\\\r\\\\n\\\\r\\\\n\\\\tvar TextDecoder = function(encoding, options) {\\\\r\\\\n\\\\t\\\\tif (utf8Encodings.indexOf(encoding) < 0 && typeof encoding !== \\'undefined\\' && encoding != null) {\\\\r\\\\n\\\\t\\\\t\\\\tthrow new RangeError(\\'Invalid encoding type. Only utf-8 is supported\\');\\\\r\\\\n\\\\t\\\\t}\\\\r\\\\n\\\\t\\\\telse {\\\\r\\\\n\\\\t\\\\t\\\\tthis.encoding = \\'utf-8\\';\\\\r\\\\n\\\\t\\\\t\\\\tthis.ignoreBOM = false;\\\\r\\\\n\\\\t\\\\t\\\\tthis.fatal = (typeof options !== \\'undefined\\' && fatal in options) ? options.fatal : false;\\\\r\\\\n\\\\t\\\\t\\\\tif (typeof this.fatal !== \\'boolean\\') {\\\\r\\\\n\\\\t\\\\t\\\\t\\\\tthrow new TypeError(\\'fatal flag must be boolean\\');\\\\r\\\\n\\\\t\\\\t\\\\t}\\\\r\\\\n\\\\t\\\\t\\\\tthis.decode = function (view, options) {\\\\r\\\\n\\\\t\\\\t\\\\t\\\\tif (typeof view === \\'undefined\\') {\\\\r\\\\n\\\\t\\\\t\\\\t\\\\t\\\\treturn \\'\\';\\\\r\\\\n\\\\t\\\\t\\\\t\\\\t}\\\\r\\\\n\\\\r\\\\n\\\\t\\\\t\\\\t\\\\tvar stream = (typeof options !== \\'undefined\\' && stream in options) ? options.stream : false;\\\\r\\\\n\\\\t\\\\t\\\\t\\\\tif (typeof stream !== \\'boolean\\') {\\\\r\\\\n\\\\t\\\\t\\\\t\\\\t\\\\tthrow new TypeError(\\'stream option must be boolean\\');\\\\r\\\\n\\\\t\\\\t\\\\t\\\\t}\\\\r\\\\n\\\\r\\\\n\\\\t\\\\t\\\\t\\\\tif (!ArrayBuffer.isView(view)) {\\\\r\\\\n\\\\t\\\\t\\\\t\\\\t\\\\tthrow new TypeError(\\'passed argument must be an array buffer view\\');\\\\r\\\\n\\\\t\\\\t\\\\t\\\\t} else {\\\\r\\\\n\\\\t\\\\t\\\\t\\\\t\\\\tvar arr = new Uint8Array(view.buffer),\\\\r\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tcharArr = new Array(arr.length);\\\\r\\\\n\\\\t\\\\t\\\\t\\\\t\\\\tarr.forEach(function(charcode, i) {\\\\r\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tcharArr[i] = String.fromCharCode(charcode);\\\\r\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t});\\\\r\\\\n\\\\t\\\\t\\\\t\\\\t\\\\treturn decodeURIComponent(escape(charArr.join(\\'\\')));\\\\r\\\\n\\\\t\\\\t\\\\t\\\\t}\\\\r\\\\n\\\\t\\\\t\\\\t}\\\\r\\\\n\\\\t\\\\t}\\\\r\\\\n\\\\t}\\\\r\\\\n\\\\treturn {\\'TextEncoder\\': TextEncoder, \\'TextDecoder\\': TextDecoder};\\\\r\\\\n}));\\\\n\\\\n//# sourceURL=webpack:///./node_modules/text-encoding-shim/index.js?\\\");\\n\\n/***/ }),\\n\\n/***/ \\\"./polyfill.ts\\\":\\n/*!*********************!*\\\\\\n  !*** ./polyfill.ts ***!\\n  \\\\*********************/\\n/*! no static exports found */\\n/***/ (function(module, exports) {\\n\\neval(\\\"if (Uint8Array.prototype.indexOf === undefined) {\\\\r\\\\n    Uint8Array.prototype.indexOf = function (value) {\\\\r\\\\n        return Array.prototype.indexOf.call(this, value);\\\\r\\\\n    };\\\\r\\\\n}\\\\r\\\\nif (Uint8Array.prototype.slice === undefined) {\\\\r\\\\n    Uint8Array.prototype.slice = function (begin, end) {\\\\r\\\\n        return new Uint8Array(Array.prototype.slice.call(this, begin, end));\\\\r\\\\n    };\\\\r\\\\n}\\\\r\\\\nif (!Uint8Array.prototype.forEach) {\\\\r\\\\n    Uint8Array.prototype.forEach = function (callback /*, thisArg*/) {\\\\r\\\\n        var T, k;\\\\r\\\\n        if (this == null) {\\\\r\\\\n            throw new TypeError(\\'this is null or not defined\\');\\\\r\\\\n        }\\\\r\\\\n        // 1. Let O be the result of calling toObject() passing the\\\\r\\\\n        // |this| value as the argument.\\\\r\\\\n        var O = Object(this);\\\\r\\\\n        // 2. Let lenValue be the result of calling the Get() internal\\\\r\\\\n        // method of O with the argument \\\\\\\"length\\\\\\\".\\\\r\\\\n        // 3. Let len be toUint32(lenValue).\\\\r\\\\n        var len = O.length >>> 0;\\\\r\\\\n        // 4. If isCallable(callback) is false, throw a TypeError exception. \\\\r\\\\n        // See: http://es5.github.com/#x9.11\\\\r\\\\n        if (typeof callback !== \\'function\\') {\\\\r\\\\n            throw new TypeError(callback + \\' is not a function\\');\\\\r\\\\n        }\\\\r\\\\n        // 5. If thisArg was supplied, let T be thisArg; else let\\\\r\\\\n        // T be undefined.\\\\r\\\\n        if (arguments.length > 1) {\\\\r\\\\n            T = arguments[1];\\\\r\\\\n        }\\\\r\\\\n        // 6. Let k be 0.\\\\r\\\\n        k = 0;\\\\r\\\\n        // 7. Repeat while k < len.\\\\r\\\\n        while (k < len) {\\\\r\\\\n            var kValue;\\\\r\\\\n            // a. Let Pk be ToString(k).\\\\r\\\\n            //    This is implicit for LHS operands of the in operator.\\\\r\\\\n            // b. Let kPresent be the result of calling the HasProperty\\\\r\\\\n            //    internal method of O with argument Pk.\\\\r\\\\n            //    This step can be combined with c.\\\\r\\\\n            // c. If kPresent is true, then\\\\r\\\\n            if (k in O) {\\\\r\\\\n                // i. Let kValue be the result of calling the Get internal\\\\r\\\\n                // method of O with argument Pk.\\\\r\\\\n                kValue = O[k];\\\\r\\\\n                // ii. Call the Call internal method of callback with T as\\\\r\\\\n                // the this value and argument list containing kValue, k, and O.\\\\r\\\\n                callback.call(T, kValue, k, O);\\\\r\\\\n            }\\\\r\\\\n            // d. Increase k by 1.\\\\r\\\\n            k++;\\\\r\\\\n        }\\\\r\\\\n        // 8. return undefined.\\\\r\\\\n    };\\\\r\\\\n}\\\\r\\\\n\\\\n\\\\n//# sourceURL=webpack:///./polyfill.ts?\\\");\\n\\n/***/ }),\\n\\n/***/ \\\"./text-encoding.ts\\\":\\n/*!**************************!*\\\\\\n  !*** ./text-encoding.ts ***!\\n  \\\\**************************/\\n/*! no static exports found */\\n/***/ (function(module, exports, __webpack_require__) {\\n\\n\\\"use strict\\\";\\neval(\\\"\\\\r\\\\n// This file is used to fix an issue in text-encoding-shim\\\\r\\\\n// See https://gitlab.com/PseudoPsycho/text-encoding-shim/issues/1 for details\\\\r\\\\nexports.__esModule = true;\\\\r\\\\nif (typeof window === \\'undefined\\' && typeof self !== \\'undefined\\') {\\\\r\\\\n    self[\\'window\\'] = self;\\\\r\\\\n}\\\\r\\\\nvar text_encoding_shim_1 = __webpack_require__(/*! text-encoding-shim */ \\\\\\\"./node_modules/text-encoding-shim/index.js\\\\\\\");\\\\r\\\\nexports.TextDecoder = text_encoding_shim_1.TextDecoder;\\\\r\\\\n\\\\n\\\\n//# sourceURL=webpack:///./text-encoding.ts?\\\");\\n\\n/***/ }),\\n\\n/***/ \\\"./txt-reader-worker.ts\\\":\\n/*!******************************!*\\\\\\n  !*** ./txt-reader-worker.ts ***!\\n  \\\\******************************/\\n/*! no static exports found */\\n/***/ (function(module, exports, __webpack_require__) {\\n\\n\\\"use strict\\\";\\neval(\\\"\\\\r\\\\nexports.__esModule = true;\\\\r\\\\nvar text_encoding_1 = __webpack_require__(/*! ./text-encoding */ \\\\\\\"./text-encoding.ts\\\\\\\");\\\\r\\\\n__webpack_require__(/*! ./polyfill */ \\\\\\\"./polyfill.ts\\\\\\\");\\\\r\\\\nvar utf8decoder = new text_encoding_1.TextDecoder(\\'utf-8\\');\\\\r\\\\nvar DEFAULT_CHUNK_SIZE = 1024 * 1024 * 50;\\\\r\\\\nvar currentTaskId = null;\\\\r\\\\nvar txtReaderWorker = null;\\\\r\\\\nvar verboseLogging = false;\\\\r\\\\nvar useTransferrable = navigator.userAgent.indexOf(\\'Firefox\\') > -1;\\\\r\\\\nvar respondMessage = function (responseMessage) {\\\\r\\\\n    if (responseMessage.done) {\\\\r\\\\n        currentTaskId = null;\\\\r\\\\n    }\\\\r\\\\n    postMessage.apply(null, [responseMessage]);\\\\r\\\\n};\\\\r\\\\nvar respondTransferrableMessage = function (responseMessage, arr) {\\\\r\\\\n    if (responseMessage.done) {\\\\r\\\\n        currentTaskId = null;\\\\r\\\\n    }\\\\r\\\\n    postMessage.apply(null, [responseMessage, arr]);\\\\r\\\\n};\\\\r\\\\nvar createProgressResponseMessage = function (progress) {\\\\r\\\\n    var responseMessage = new ResponseMessage(progress);\\\\r\\\\n    responseMessage.done = false;\\\\r\\\\n    return responseMessage;\\\\r\\\\n};\\\\r\\\\nvar validateWorker = function () {\\\\r\\\\n    if (txtReaderWorker === null) {\\\\r\\\\n        respondMessage(new ResponseMessage(false, \\'File has not been loaded into the worker, need to loadFile first.\\'));\\\\r\\\\n        return false;\\\\r\\\\n    }\\\\r\\\\n    return true;\\\\r\\\\n};\\\\r\\\\nvar mergeUint8Array = function (x, y) {\\\\r\\\\n    if (x.byteLength === 0) {\\\\r\\\\n        return y;\\\\r\\\\n    }\\\\r\\\\n    if (y.byteLength === 0) {\\\\r\\\\n        return x;\\\\r\\\\n    }\\\\r\\\\n    var z = new Uint8Array(x.byteLength + y.byteLength);\\\\r\\\\n    z.set(x, 0);\\\\r\\\\n    z.set(y, x.byteLength);\\\\r\\\\n    return z;\\\\r\\\\n};\\\\r\\\\nself.addEventListener(\\'message\\', function (event) {\\\\r\\\\n    var req = event.data;\\\\r\\\\n    if (verboseLogging) {\\\\r\\\\n        console.log(\\'Worker thread received a message from main thread: \\\\\\\\r\\\\\\\\n\\', event.data);\\\\r\\\\n    }\\\\r\\\\n    if (currentTaskId !== null) {\\\\r\\\\n        throw (\\'The worker thread is busy.\\');\\\\r\\\\n    }\\\\r\\\\n    currentTaskId = req.taskId;\\\\r\\\\n    switch (req.action) {\\\\r\\\\n        case \\'loadFile\\':\\\\r\\\\n            txtReaderWorker = new TxtReaderWorker(req.data.file, req.data.config);\\\\r\\\\n            break;\\\\r\\\\n        case \\'enableVerbose\\':\\\\r\\\\n            verboseLogging = true;\\\\r\\\\n            respondMessage(new ResponseMessage(true));\\\\r\\\\n            break;\\\\r\\\\n        case \\'setChunkSize\\':\\\\r\\\\n            if (typeof req.data !== \\'number\\' || req.data < 1) {\\\\r\\\\n                respondMessage(new ResponseMessage(false, \\'Invalid CHUNK_SIZE, must be greater than 1.\\'));\\\\r\\\\n                return;\\\\r\\\\n            }\\\\r\\\\n            if (txtReaderWorker) {\\\\r\\\\n                txtReaderWorker.CHUNK_SIZE = req.data;\\\\r\\\\n            }\\\\r\\\\n            DEFAULT_CHUNK_SIZE = req.data;\\\\r\\\\n            respondMessage(new ResponseMessage(DEFAULT_CHUNK_SIZE));\\\\r\\\\n            break;\\\\r\\\\n        case \\'getLines\\':\\\\r\\\\n            if (validateWorker()) {\\\\r\\\\n                txtReaderWorker.getLines(req.data.start, req.data.count);\\\\r\\\\n            }\\\\r\\\\n            break;\\\\r\\\\n        case \\'iterateLines\\':\\\\r\\\\n            if (validateWorker()) {\\\\r\\\\n                txtReaderWorker.iterateLines(req.data);\\\\r\\\\n            }\\\\r\\\\n            break;\\\\r\\\\n    }\\\\r\\\\n});\\\\r\\\\nvar ResponseMessage = /** @class */ (function () {\\\\r\\\\n    function ResponseMessage(x, y, z) {\\\\r\\\\n        this.taskId = currentTaskId;\\\\r\\\\n        if (arguments.length === 1) {\\\\r\\\\n            this.success = true;\\\\r\\\\n            this.message = \\'\\';\\\\r\\\\n            this.result = x;\\\\r\\\\n        }\\\\r\\\\n        else if (arguments.length === 2) {\\\\r\\\\n            switch (typeof x) {\\\\r\\\\n                case \\'boolean\\':\\\\r\\\\n                    this.success = x;\\\\r\\\\n                    this.message = y;\\\\r\\\\n                    this.result = null;\\\\r\\\\n                    break;\\\\r\\\\n                default:\\\\r\\\\n                    this.success = true;\\\\r\\\\n                    this.message = x;\\\\r\\\\n                    this.result = y;\\\\r\\\\n            }\\\\r\\\\n        }\\\\r\\\\n        else {\\\\r\\\\n            this.success = x;\\\\r\\\\n            this.message = y;\\\\r\\\\n            this.result = z;\\\\r\\\\n        }\\\\r\\\\n        this.done = true;\\\\r\\\\n    }\\\\r\\\\n    return ResponseMessage;\\\\r\\\\n}());\\\\r\\\\nvar Iterator = /** @class */ (function () {\\\\r\\\\n    function Iterator() {\\\\r\\\\n        this.lineView = new Uint8Array(0);\\\\r\\\\n        this.lastViewEndsWithCR = false;\\\\r\\\\n        this.onEachLineInternal = null;\\\\r\\\\n        this.onEachLine = null;\\\\r\\\\n        this.eachLineScope = null;\\\\r\\\\n        this.onSeekComplete = null;\\\\r\\\\n        this.offset = 0;\\\\r\\\\n        this.createMap = false;\\\\r\\\\n        this.endOffset = null;\\\\r\\\\n        this.linesToIterate = 0;\\\\r\\\\n        this.linesProcessed = 0;\\\\r\\\\n        this.currentLineNumber = 1;\\\\r\\\\n        this.startLineNumber = 0;\\\\r\\\\n        this.lastProgress = null;\\\\r\\\\n        this.processedViewLength = 0;\\\\r\\\\n        this.lineBreakLength = 0;\\\\r\\\\n        this.map = [];\\\\r\\\\n        this.lastMappedProgress = null;\\\\r\\\\n    }\\\\r\\\\n    Iterator.prototype.shouldBreak = function () {\\\\r\\\\n        if (this.isPartialIterate() && this.linesProcessed === this.linesToIterate) {\\\\r\\\\n            return true;\\\\r\\\\n        }\\\\r\\\\n        else {\\\\r\\\\n            return false;\\\\r\\\\n        }\\\\r\\\\n    };\\\\r\\\\n    Iterator.prototype.isPartialIterate = function () {\\\\r\\\\n        return this.linesToIterate > 0;\\\\r\\\\n    };\\\\r\\\\n    Iterator.prototype.hitLine = function (lineData) {\\\\r\\\\n        var isPartialIterate = this.isPartialIterate();\\\\r\\\\n        var progress = 0;\\\\r\\\\n        if (!isPartialIterate ||\\\\r\\\\n            (isPartialIterate && this.currentLineNumber >= this.startLineNumber)) {\\\\r\\\\n            this.linesProcessed++;\\\\r\\\\n            if (isPartialIterate) {\\\\r\\\\n                progress = Math.round(this.linesProcessed / this.linesToIterate * 10000) / 100;\\\\r\\\\n            }\\\\r\\\\n            else {\\\\r\\\\n                progress = Math.round(this.processedViewLength / this.endOffset * 10000) / 100;\\\\r\\\\n            }\\\\r\\\\n            if (this.createMap) {\\\\r\\\\n                var currentProgress = Math.round(progress);\\\\r\\\\n                if (this.lastMappedProgress === null ||\\\\r\\\\n                    this.lastMappedProgress < currentProgress) {\\\\r\\\\n                    this.lastMappedProgress = currentProgress;\\\\r\\\\n                    this.map.push({\\\\r\\\\n                        line: this.currentLineNumber,\\\\r\\\\n                        offset: this.processedViewLength\\\\r\\\\n                    });\\\\r\\\\n                }\\\\r\\\\n            }\\\\r\\\\n            if (this.onEachLineInternal !== null) {\\\\r\\\\n                if (lineData.buffer.byteLength != lineData.byteLength) {\\\\r\\\\n                    lineData = new Uint8Array(lineData);\\\\r\\\\n                }\\\\r\\\\n                this.onEachLineInternal.call(self, lineData, progress);\\\\r\\\\n            }\\\\r\\\\n            if (this.onEachLine !== null) {\\\\r\\\\n                if (lineData.buffer.byteLength != lineData.byteLength) {\\\\r\\\\n                    lineData = new Uint8Array(lineData);\\\\r\\\\n                }\\\\r\\\\n                this.onEachLine.call(this.eachLineScope, lineData, progress, this.currentLineNumber);\\\\r\\\\n            }\\\\r\\\\n        }\\\\r\\\\n        if (isPartialIterate) {\\\\r\\\\n            if (this.shouldReportProgress(progress)) {\\\\r\\\\n                this.lastProgress = progress;\\\\r\\\\n                respondMessage(createProgressResponseMessage(progress < 100 ? progress : 100));\\\\r\\\\n            }\\\\r\\\\n        }\\\\r\\\\n        this.processedViewLength += lineData.length + this.lineBreakLength;\\\\r\\\\n        this.currentLineNumber++;\\\\r\\\\n    };\\\\r\\\\n    Iterator.prototype.shouldReportProgress = function (currentProgress) {\\\\r\\\\n        if (this.lastProgress === null) {\\\\r\\\\n            return true;\\\\r\\\\n        }\\\\r\\\\n        else if (currentProgress - this.lastProgress > 5) {\\\\r\\\\n            return true;\\\\r\\\\n        }\\\\r\\\\n        else {\\\\r\\\\n            return false;\\\\r\\\\n        }\\\\r\\\\n    };\\\\r\\\\n    Iterator.prototype.bindEachLineFromConfig = function (config) {\\\\r\\\\n        this.onEachLine = new Function(\\'return \\' + config.eachLine)();\\\\r\\\\n        this.eachLineScope = config.scope;\\\\r\\\\n        this.eachLineScope[\\'decode\\'] = function (value) {\\\\r\\\\n            return utf8decoder.decode(value);\\\\r\\\\n        };\\\\r\\\\n    };\\\\r\\\\n    return Iterator;\\\\r\\\\n}());\\\\r\\\\nvar TxtReaderWorker = /** @class */ (function () {\\\\r\\\\n    function TxtReaderWorker(file, onNewLineConfig) {\\\\r\\\\n        var _this = this;\\\\r\\\\n        if (Object.prototype.toString.call(file).toLowerCase() !== \\'[object file]\\') {\\\\r\\\\n            respondMessage(new ResponseMessage(false, \\'Invalid file object\\'));\\\\r\\\\n            return;\\\\r\\\\n        }\\\\r\\\\n        this.CHUNK_SIZE = DEFAULT_CHUNK_SIZE;\\\\r\\\\n        this.file = file;\\\\r\\\\n        this.lineCount = 0;\\\\r\\\\n        this.quickSearchMap = [];\\\\r\\\\n        this.fr = new FileReader();\\\\r\\\\n        this.fr.onload = function () {\\\\r\\\\n            var view = new Uint8Array(_this.fr.result);\\\\r\\\\n            var viewTotalLength = _this.fr.result.byteLength;\\\\r\\\\n            var iterator = _this.iterator;\\\\r\\\\n            while (view.length > 0) {\\\\r\\\\n                // first CR (0x0D, \\\\\\\\r) position in the view\\\\r\\\\n                var crIndex = view.indexOf(13);\\\\r\\\\n                // first LF (0x0A, \\\\\\\\n) position in the view\\\\r\\\\n                var lfIndex = view.indexOf(10);\\\\r\\\\n                // for CRLF linebreakLength would be 2, otherwise the value would be 1.\\\\r\\\\n                var lineBreakIndex = void 0;\\\\r\\\\n                // If merge all view to lineView\\\\r\\\\n                var mergeAll = false;\\\\r\\\\n                // If current view ends with CR\\\\r\\\\n                var endsWithCR = false;\\\\r\\\\n                if (crIndex > 0 && (lfIndex === -1 || crIndex < lfIndex)) {\\\\r\\\\n                    // CR is hit before LF in the view or there is only CR hit in the view\\\\r\\\\n                    // CR is in the middle or end\\\\r\\\\n                    if (crIndex < view.length - 1) {\\\\r\\\\n                        // CR in the middle\\\\r\\\\n                        if (view[crIndex + 1] === 10) {\\\\r\\\\n                            // CRLF\\\\r\\\\n                            lineBreakIndex = crIndex;\\\\r\\\\n                            iterator.lineBreakLength = 2;\\\\r\\\\n                        }\\\\r\\\\n                        else {\\\\r\\\\n                            // CR only in the middle\\\\r\\\\n                            lineBreakIndex = crIndex;\\\\r\\\\n                            iterator.lineBreakLength = 1;\\\\r\\\\n                        }\\\\r\\\\n                    }\\\\r\\\\n                    else {\\\\r\\\\n                        // CR in the end, do MERGEALL first since not sure the linebreak is CR or CRLF\\\\r\\\\n                        endsWithCR = true;\\\\r\\\\n                        mergeAll = true;\\\\r\\\\n                    }\\\\r\\\\n                }\\\\r\\\\n                else if (crIndex === 0) {\\\\r\\\\n                    // CR is the first byte\\\\r\\\\n                    if (view.length > 1) {\\\\r\\\\n                        if (view[1] === 10) {\\\\r\\\\n                            // CRLF at beginning\\\\r\\\\n                            lineBreakIndex = crIndex;\\\\r\\\\n                            iterator.lineBreakLength = 2;\\\\r\\\\n                        }\\\\r\\\\n                        else {\\\\r\\\\n                            // CR only at beginning\\\\r\\\\n                            lineBreakIndex = crIndex;\\\\r\\\\n                            iterator.lineBreakLength = 1;\\\\r\\\\n                        }\\\\r\\\\n                    }\\\\r\\\\n                    else {\\\\r\\\\n                        // rare scenario: view length is 1 and the content is CR, CR is not only the first byte but also the last byte\\\\r\\\\n                        // do MERGEALL first since not sure the linebreak is CR or CRLF\\\\r\\\\n                        endsWithCR = true;\\\\r\\\\n                        mergeAll = true;\\\\r\\\\n                    }\\\\r\\\\n                }\\\\r\\\\n                else {\\\\r\\\\n                    // no CR in the view or LF is hit before CR\\\\r\\\\n                    if (lfIndex > 0) {\\\\r\\\\n                        // LF is in the middle or end, no need to check the CRLF scenario since no CR is found before LF postion\\\\r\\\\n                        lineBreakIndex = lfIndex;\\\\r\\\\n                        iterator.lineBreakLength = 1;\\\\r\\\\n                    }\\\\r\\\\n                    else if (lfIndex === 0) {\\\\r\\\\n                        // LF is the first byte, need to check if the last byte of lineView is CR\\\\r\\\\n                        iterator.lineBreakLength = iterator.lastViewEndsWithCR ? 2 : 1;\\\\r\\\\n                        iterator.hitLine(iterator.lastViewEndsWithCR ? iterator.lineView.slice(0, iterator.lineView.length - 1) : iterator.lineView);\\\\r\\\\n                        if (iterator.shouldBreak()) {\\\\r\\\\n                            break;\\\\r\\\\n                        }\\\\r\\\\n                        iterator.lineView = new Uint8Array(0);\\\\r\\\\n                        view = new Uint8Array(_this.fr.result, 1 + view.byteOffset);\\\\r\\\\n                        iterator.lastViewEndsWithCR = false;\\\\r\\\\n                        continue;\\\\r\\\\n                    }\\\\r\\\\n                    else {\\\\r\\\\n                        // no LF found\\\\r\\\\n                        mergeAll = true;\\\\r\\\\n                    }\\\\r\\\\n                }\\\\r\\\\n                if (!mergeAll) {\\\\r\\\\n                    if (iterator.lastViewEndsWithCR) {\\\\r\\\\n                        // lineView is like: ****CR, just treat **** as a new line, no need to check if the current view starts with LF since it is handled by LF first byte scenario\\\\r\\\\n                        iterator.hitLine(iterator.lineView.slice(0, iterator.lineView.length - 1));\\\\r\\\\n                        if (iterator.shouldBreak()) {\\\\r\\\\n                            break;\\\\r\\\\n                        }\\\\r\\\\n                        // treat the view as a new line\\\\r\\\\n                        iterator.hitLine(view.slice(0, lineBreakIndex));\\\\r\\\\n                        if (iterator.shouldBreak()) {\\\\r\\\\n                            break;\\\\r\\\\n                        }\\\\r\\\\n                        // reset lastViewEndsWithCR to prevent it being treated again for next view\\\\r\\\\n                        iterator.lastViewEndsWithCR = false;\\\\r\\\\n                    }\\\\r\\\\n                    else {\\\\r\\\\n                        // merge the view line into lineView\\\\r\\\\n                        iterator.lineView = mergeUint8Array(iterator.lineView, view.slice(0, lineBreakIndex));\\\\r\\\\n                        // treat the lineView as a whole line\\\\r\\\\n                        iterator.hitLine(iterator.lineView);\\\\r\\\\n                        if (iterator.shouldBreak()) {\\\\r\\\\n                            break;\\\\r\\\\n                        }\\\\r\\\\n                    }\\\\r\\\\n                    // clear lineView\\\\r\\\\n                    iterator.lineView = new Uint8Array(0);\\\\r\\\\n                    // remove the processed view\\\\r\\\\n                    view = new Uint8Array(_this.fr.result, view.byteOffset + lineBreakIndex + iterator.lineBreakLength);\\\\r\\\\n                }\\\\r\\\\n                else {\\\\r\\\\n                    // do merge all, which means no CR or LF found\\\\r\\\\n                    if (iterator.lastViewEndsWithCR) {\\\\r\\\\n                        // lineView is like: ****CR, just treat **** as a new line\\\\r\\\\n                        iterator.lineBreakLength = 1;\\\\r\\\\n                        iterator.hitLine(iterator.lineView.slice(0, iterator.lineView.length - 1));\\\\r\\\\n                        if (iterator.shouldBreak()) {\\\\r\\\\n                            break;\\\\r\\\\n                        }\\\\r\\\\n                        // clear lineView\\\\r\\\\n                        iterator.lineView = new Uint8Array(0);\\\\r\\\\n                    }\\\\r\\\\n                    // merge the view to lineView\\\\r\\\\n                    iterator.lineView = mergeUint8Array(iterator.lineView, view);\\\\r\\\\n                    iterator.lastViewEndsWithCR = endsWithCR;\\\\r\\\\n                    break; // break the while as all rest view is processed\\\\r\\\\n                }\\\\r\\\\n            }\\\\r\\\\n            if (!iterator.isPartialIterate()) {\\\\r\\\\n                var progress = Math.round(iterator.offset / _this.file.size * 10000) / 100;\\\\r\\\\n                respondMessage(createProgressResponseMessage(progress < 100 ? progress : 100));\\\\r\\\\n            }\\\\r\\\\n            iterator.offset += _this.CHUNK_SIZE;\\\\r\\\\n            iterator.lineBreakLength = 0;\\\\r\\\\n            _this.seek();\\\\r\\\\n        };\\\\r\\\\n        this.iterator = new Iterator();\\\\r\\\\n        this.iterator.createMap = true;\\\\r\\\\n        this.iterator.endOffset = this.file.size;\\\\r\\\\n        if (onNewLineConfig) {\\\\r\\\\n            this.iterator.bindEachLineFromConfig(onNewLineConfig);\\\\r\\\\n        }\\\\r\\\\n        this.iterateLinesInternal(function (line, progress) {\\\\r\\\\n            _this.lineCount++;\\\\r\\\\n        }, function () {\\\\r\\\\n            _this.quickSearchMap = _this.iterator.map;\\\\r\\\\n            var result = {\\\\r\\\\n                lineCount: _this.lineCount\\\\r\\\\n            };\\\\r\\\\n            if (onNewLineConfig) {\\\\r\\\\n                delete _this.iterator.eachLineScope[\\'decode\\'];\\\\r\\\\n                result.scope = _this.iterator.eachLineScope;\\\\r\\\\n            }\\\\r\\\\n            respondMessage(new ResponseMessage(result));\\\\r\\\\n        });\\\\r\\\\n    }\\\\r\\\\n    TxtReaderWorker.prototype.setPartialIterator = function (start, count) {\\\\r\\\\n        if (start < 1 || start > this.lineCount) {\\\\r\\\\n            respondMessage(new ResponseMessage(false, \\'Start line number is invalid\\'));\\\\r\\\\n            return false;\\\\r\\\\n        }\\\\r\\\\n        else {\\\\r\\\\n            var endLineNumber = start + count - 1;\\\\r\\\\n            endLineNumber = endLineNumber > this.lineCount ? this.lineCount : endLineNumber;\\\\r\\\\n            for (var i = 0; i < this.quickSearchMap.length; i++) {\\\\r\\\\n                if (start >= this.quickSearchMap[i].line && (i === this.quickSearchMap.length - 1 || start < this.quickSearchMap[i + 1].line)) {\\\\r\\\\n                    this.iterator.offset = this.quickSearchMap[i].offset;\\\\r\\\\n                    this.iterator.currentLineNumber = this.quickSearchMap[i].line;\\\\r\\\\n                }\\\\r\\\\n                if (endLineNumber < this.quickSearchMap[i].line && (i === 0 || endLineNumber >= this.quickSearchMap[i - 1].line)) {\\\\r\\\\n                    this.iterator.endOffset = this.quickSearchMap[i].offset;\\\\r\\\\n                }\\\\r\\\\n                else {\\\\r\\\\n                    this.iterator.endOffset = this.file.size;\\\\r\\\\n                }\\\\r\\\\n            }\\\\r\\\\n            this.iterator.linesToIterate = count;\\\\r\\\\n            this.iterator.startLineNumber = start;\\\\r\\\\n            return true;\\\\r\\\\n        }\\\\r\\\\n    };\\\\r\\\\n    TxtReaderWorker.prototype.iterateLinesInternal = function (onNewLineFunc, onSeekCompleteFunc) {\\\\r\\\\n        this.iterator.onEachLineInternal = onNewLineFunc;\\\\r\\\\n        this.iterator.onSeekComplete = onSeekCompleteFunc || null;\\\\r\\\\n        this.seek();\\\\r\\\\n    };\\\\r\\\\n    TxtReaderWorker.prototype.iterateLines = function (data) {\\\\r\\\\n        var _this = this;\\\\r\\\\n        var config = data.config;\\\\r\\\\n        this.iterator.offset = 0;\\\\r\\\\n        this.iterator.endOffset = this.file.size;\\\\r\\\\n        this.iterator.bindEachLineFromConfig(config);\\\\r\\\\n        this.iterator.onSeekComplete = function () {\\\\r\\\\n            delete _this.iterator.eachLineScope[\\'decode\\'];\\\\r\\\\n            respondMessage(new ResponseMessage(_this.iterator.eachLineScope));\\\\r\\\\n        };\\\\r\\\\n        if (data.start !== null && data.count !== null) {\\\\r\\\\n            var setResult = this.setPartialIterator(data.start, data.count);\\\\r\\\\n            if (!setResult) {\\\\r\\\\n                return;\\\\r\\\\n            }\\\\r\\\\n        }\\\\r\\\\n        this.seek();\\\\r\\\\n    };\\\\r\\\\n    TxtReaderWorker.prototype.seek = function () {\\\\r\\\\n        var finishDueToLinesToIterateReached = this.iterator.linesToIterate > 0 && this.iterator.linesProcessed === this.iterator.linesToIterate;\\\\r\\\\n        if (this.iterator.offset >= this.iterator.endOffset || finishDueToLinesToIterateReached) {\\\\r\\\\n            respondMessage(createProgressResponseMessage(100));\\\\r\\\\n            if (this.iterator.lineView.byteLength && !finishDueToLinesToIterateReached) {\\\\r\\\\n                this.iterator.hitLine(this.iterator.lineView);\\\\r\\\\n                this.iterator.lineView = new Uint8Array(0);\\\\r\\\\n            }\\\\r\\\\n            if (this.iterator.onSeekComplete !== null) {\\\\r\\\\n                this.iterator.onSeekComplete.call(self);\\\\r\\\\n            }\\\\r\\\\n            this.iterator = new Iterator();\\\\r\\\\n        }\\\\r\\\\n        else {\\\\r\\\\n            var slice = this.file.slice(this.iterator.offset, this.iterator.offset + this.CHUNK_SIZE);\\\\r\\\\n            this.fr.readAsArrayBuffer(slice);\\\\r\\\\n        }\\\\r\\\\n    };\\\\r\\\\n    TxtReaderWorker.prototype.getLines = function (start, count) {\\\\r\\\\n        if (this.setPartialIterator(start, count)) {\\\\r\\\\n            var lines_1 = [];\\\\r\\\\n            var linesBuffer_1 = [];\\\\r\\\\n            this.iterateLinesInternal(function (line) {\\\\r\\\\n                lines_1.push(line);\\\\r\\\\n                if (useTransferrable) {\\\\r\\\\n                    linesBuffer_1.push(line.buffer);\\\\r\\\\n                }\\\\r\\\\n            }, function () {\\\\r\\\\n                if (useTransferrable) {\\\\r\\\\n                    respondTransferrableMessage(new ResponseMessage(lines_1), linesBuffer_1);\\\\r\\\\n                }\\\\r\\\\n                else {\\\\r\\\\n                    respondMessage(new ResponseMessage(lines_1));\\\\r\\\\n                }\\\\r\\\\n            });\\\\r\\\\n        }\\\\r\\\\n    };\\\\r\\\\n    return TxtReaderWorker;\\\\r\\\\n}());\\\\r\\\\n\\\\n\\\\n//# sourceURL=webpack:///./txt-reader-worker.ts?\\\");\\n\\n/***/ })\\n\\n/******/ });\"])));\r\n        this.worker.addEventListener('message', function (event) {\r\n            if (_this.verboseLogging) {\r\n                console.log('Main thread received a message from worker thread: \\r\\n', event.data);\r\n            }\r\n            var response = event.data;\r\n            if (response.taskId !== _this.runningTask.id) {\r\n                throw (\"Received task ID (\" + response.taskId + \") does not match the running task ID (\" + _this.runningTask.id + \").\");\r\n            }\r\n            if (response.done) {\r\n                // the task completes\r\n                _this.completeTask(response);\r\n            }\r\n            else {\r\n                // the task is incomplete, means it is a progress message\r\n                if (Object.prototype.toString.call(response.result).toLowerCase() === '[object number]' && response.result >= 0 && response.result <= 100) {\r\n                    _this.runningTask.updateProgress(response.result);\r\n                }\r\n                else {\r\n                    throw ('Unkown message type');\r\n                }\r\n            }\r\n        }, false);\r\n    }\r\n    TxtReader.prototype.loadFile = function (file, config) {\r\n        var _this = this;\r\n        this.file = file;\r\n        Object.defineProperty(this, 'lineCount', {\r\n            value: 0,\r\n            writable: false\r\n        });\r\n        var data = {\r\n            file: file\r\n        };\r\n        if (config) {\r\n            data.config = this.getItertorConfigMessage(config);\r\n        }\r\n        return this.newTask('loadFile', data).then(function (response) {\r\n            Object.defineProperty(_this, 'lineCount', {\r\n                value: response.result.lineCount,\r\n                writable: false\r\n            });\r\n        });\r\n    };\r\n    TxtReader.prototype.setChunkSize = function (chunkSize) {\r\n        return this.newTask('setChunkSize', chunkSize);\r\n    };\r\n    TxtReader.prototype.enableVerbose = function () {\r\n        this.verboseLogging = true;\r\n        return this.newTask('enableVerbose');\r\n    };\r\n    TxtReader.prototype.getLines = function (start, count) {\r\n        var _this = this;\r\n        return this.newTask('getLines', {\r\n            start: start,\r\n            count: count\r\n        }).then(function (response) {\r\n            for (var i = 0; i < response.result.length; i++) {\r\n                response.result[i] = _this.utf8decoder.decode(response.result[i]);\r\n            }\r\n        });\r\n    };\r\n    TxtReader.prototype.iterateLines = function (config, start, count) {\r\n        return this.newTask('iterateLines', {\r\n            config: this.getItertorConfigMessage(config),\r\n            start: start || null,\r\n            count: count || null\r\n        });\r\n    };\r\n    TxtReader.prototype.getItertorConfigMessage = function (config) {\r\n        return {\r\n            eachLine: config.eachLine.toString(),\r\n            scope: config.scope || {}\r\n        };\r\n    };\r\n    TxtReader.prototype.newTask = function (action, data) {\r\n        var reqMsg = new RequestMessage(action, data);\r\n        var task = new TxtReaderTask(this.newTaskId(), reqMsg, this);\r\n        this.taskList.push(task);\r\n        if (!this.runningTask) {\r\n            this.runTask(task);\r\n        }\r\n        else {\r\n            this.queuedTaskList.push(task);\r\n            task.state = TxtReaderTaskState.Queued;\r\n        }\r\n        return task;\r\n    };\r\n    TxtReader.prototype.completeTask = function (response) {\r\n        this.runningTask.complete(response);\r\n        this.runningTask = null;\r\n        this.runNextTask();\r\n    };\r\n    TxtReader.prototype.runNextTask = function () {\r\n        if (this.queuedTaskList.length) {\r\n            this.runTask(this.queuedTaskList.shift());\r\n        }\r\n    };\r\n    TxtReader.prototype.runTask = function (task) {\r\n        this.runningTask = task;\r\n        this.worker.postMessage(task.requestMessage);\r\n        task.run();\r\n    };\r\n    TxtReader.prototype.newTaskId = function () {\r\n        var taskListLength = this.taskList.length;\r\n        if (taskListLength === 0) {\r\n            return 1;\r\n        }\r\n        else {\r\n            return this.taskList[taskListLength - 1].id + 1;\r\n        }\r\n    };\r\n    return TxtReader;\r\n}());\r\nexports.TxtReader = TxtReader;\r\n\n\n//# sourceURL=webpack:///./txt-reader.ts?")}})},function(e,n){
/*! http://mths.be/startswith v0.2.0 by @mathias */
String.prototype.startsWith||function(){"use strict";var e=function(){try{var e={},n=Object.defineProperty,t=n(e,e,e)&&n}catch(e){}return t}(),n={}.toString,t=function(e){if(null==this)throw TypeError();var t=String(this);if(e&&"[object RegExp]"==n.call(e))throw TypeError();var r=t.length,i=String(e),s=i.length,o=arguments.length>1?arguments[1]:void 0,a=o?Number(o):0;a!=a&&(a=0);var l=Math.min(Math.max(a,0),r);if(s+l>r)return!1;for(var u=-1;++u<s;)if(t.charCodeAt(l+u)!=i.charCodeAt(u))return!1;return!0};e?e(String.prototype,"startsWith",{value:t,configurable:!0,writable:!0}):String.prototype.startsWith=t}()},,function(e,n,t){},,function(e,n,t){},function(e,n,t){"use strict";n.__esModule=!0,t(10),t(8);var r=t(0),i=t(4),s=t(1);i.init(),r.init(),s.init()}]);